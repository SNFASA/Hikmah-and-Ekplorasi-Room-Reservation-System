// BookingController

public function filterAvailableRooms(Request $request)
{
    $type_room = $request->input('type_room');
    
    // Get the room type name if a specific room type is selected
    $roomTypeName = 'All';
    if ($type_room && $type_room !== 'All') {
        $roomType = \App\Models\TypeRooms::find($type_room);
        $roomTypeName = $roomType ? $roomType->name : 'All';
    }
    
    // Base validation rules
    $rules = [
        'type_room' => 'nullable|string',
        'start_time' => 'nullable|date_format:H:i',
        'end_time' => 'nullable|date_format:H:i',
        'furniture_category' => 'nullable|array',
        'furniture_category.*' => 'nullable|string',
        'electronic_category' => 'nullable|array',
        'electronic_category.*' => 'nullable|string',
    ];

    // Conditional validation based on room type name
    if ($roomTypeName == 'Courses, Meeting & Seminar') {
        $rules['start_date'] = 'nullable|date';
        $rules['end_date'] = 'nullable|date|after_or_equal:start_date';
    } elseif (in_array($roomTypeName, ['HIKMAH', 'EKSPLORASI'])) {
        $rules['date'] = 'nullable|date';
    } else { // For "All" room types
        $rules['date'] = 'nullable|date';
        $rules['start_date'] = 'nullable|date';
        $rules['end_date'] = 'nullable|date|after_or_equal:start_date';
    }

    $validated = $request->validate($rules);

    // Pass the request data as query parameters when redirecting back to the home route
    return redirect()->route('home', $request->all());
}

public function showBookingForm($id, Request $request){
            $room = Room::findOrFail($id);
               $form = Room::join('type_rooms', 'rooms.type_room', '=', 'type_rooms.id')
                ->where('rooms.no_room', $id)
                ->value('type_rooms.form_type');
            $furnitureCategories = Furniture::getFurnitureCategories();
            $electronicCategories = Electronic::getElectronicCategories();
            $start_date = $request->query('start_date');
            $end_date = $request->query('end_date');
            $date = $request->query('date'); // Retrieves date from query string
            $start_time = $request->query('start_time');
            $end_time = $request->query('end_time');
            \Log::info("Reseervation Form Params:", compact('start_date','end_date', 'start_time', 'end_time', 'form')); // Debugging
            \Log::info("Booking Form Params:", compact('date', 'start_time', 'end_time', 'form')); // Debugging
            if($form == 'standard'){
                return view('frontend.pages.bookingform', [
                    'room' => $room,
                    'date' => $date,
                    'start_time' => $start_time,
                    'end_time' => $end_time,
                    'furnitureCategories' => $furnitureCategories,
                    'electronicCategories' => $electronicCategories,
                ]);
            }else{
                return view('frontend.pages.reservationform',[
                    'room' => $room,
                    'start_date' => $start_date,
                    'end_date' => $end_date,
                    'start_time' => $start_time,
                    'end_time' => $end_time,
                    'furnitureCategories' => $furnitureCategories,
                    'electronicCategories' => $electronicCategories,
                    'form' => $form,
                ]);
            }
}

public function index(Request $request)
{
    $type_room = $request->input('type_room', 'All'); // selected value from filter
    $type_rooms = \App\Models\TypeRooms::orderBy('name')->get(); // dropdown values
    $date = $request->input('date');
    $start_date = $request->input('start_date');
    $end_date = $request->input('end_date');
    $start_time = $request->input('start_time');
    $end_time = $request->input('end_time');
    $furniture_category = $request->input('furniture_category', []);
    $electronic_category = $request->input('electronic_category', []);

    if (($start_time && !$end_time) || (!$start_time && $end_time)) {
        request()->session()->flash('error', 'Both start and end time must be provided.');
        return redirect()->back();
    }

    // Get the selected room type name
    $selectedRoomTypeName = 'All';
    if ($type_room !== 'All') {
        $selectedRoomType = \App\Models\TypeRooms::find($type_room);
        $selectedRoomTypeName = $selectedRoomType ? $selectedRoomType->name : 'All';
    }

    // Check if room type is "Courses, Meeting & Seminar" and validate date range
    if ($selectedRoomTypeName == 'Courses, Meeting & Seminar') {
        if ($start_date && $end_date && $start_date > $end_date) {
            request()->session()->flash('error', 'Start date must be before or equal to end date.');
            return redirect()->back();
        }
    }

    $rooms = room::query()
        ->where('status', 'valid')
        ->when($type_room !== 'All', function ($query) use ($type_room) {
            $query->where('type_room', $type_room);
        })
        ->when(!empty($furniture_category), function ($query) use ($furniture_category) {
            $query->whereHas('furnitures', function ($q) use ($furniture_category) {
                $q->whereIn('category_id', $furniture_category);
            });
        })
        ->when(!empty($electronic_category), function ($query) use ($electronic_category) {
            $query->whereHas('electronics', function ($q) use ($electronic_category) {
                $q->whereIn('category_id', $electronic_category);
            });
        })
        ->get();

    // Availability checking logic
    if ($start_time && $end_time) {
        foreach ($rooms as $room) {
            $roomId = $room->no_room;

            // For "Courses, Meeting & Seminar" room type - use date range
            if ($selectedRoomTypeName == 'Courses, Meeting & Seminar' && $start_date && $end_date) {
                $conflictWithUnavailable = DB::table('schedule_booking')
                    ->where('roomid', $roomId)
                    ->whereBetween('invalid_date', [$start_date, $end_date])
                    ->where(function ($q) use ($start_time, $end_time) {
                        $q->where('invalid_time_start', '<', $end_time)
                          ->where('invalid_time_end', '>', $start_time);
                    })
                    ->exists();

                if ($conflictWithUnavailable) {
                    request()->session()->flash('error', "Room $roomId is unavailable during the selected date range.");
                    return redirect()->back();
                }
                $conflictWithReserved = DB::table('facility_reservation')
                    ->where('room_id', $roomId)
                    ->where(function ($q) use ($start_date, $end_date) {
                        $q->where(function ($subQ) use ($start_date, $end_date) {
                            $subQ->where('start_date', '<=', $end_date)
                                 ->where('end_date', '>=', $start_date);
                        });
                    })
                    ->where(function ($q) use ($start_time, $end_time) {
                        $q->where('start_time', '<', $end_time)
                          ->where('end_time', '>', $start_time);
                    })
                    ->exists();

                if ($conflictWithUnavailable || $conflictWithReserved) {
                    request()->session()->flash('error', "Room $roomId is already booked during the selected date range.");
                    return redirect()->back();
                }
            }
            // For "HIKMAH" and "EKSPLORASI" room types - use single date
            elseif ($date && in_array($selectedRoomTypeName, ['HIKMAH', 'EKSPLORASI'])) {
                $conflictWithUnavailable = DB::table('schedule_booking')
                    ->where('roomid', $roomId)
                    ->where('invalid_date', $date)
                    ->where(function ($q) use ($start_time, $end_time) {
                        $q->where('invalid_time_start', '<', $end_time)
                          ->where('invalid_time_end', '>', $start_time);
                    })
                    ->exists();

                if ($conflictWithUnavailable) {
                    request()->session()->flash('error', "Room $roomId is unavailable at the selected time.");
                    return redirect()->back();
                }

                $conflictWithBooked = DB::table('bookings')
                    ->where('no_room', $roomId)
                    ->where('booking_date', $date)
                    ->where(function ($q) use ($start_time, $end_time) {
                        $q->where('booking_time_start', '<', $end_time)
                          ->where('booking_time_end', '>', $start_time);
                    })
                    ->exists();

                if ($conflictWithBooked) {
                    request()->session()->flash('error', "Room $roomId is already booked at the selected time.");
                    return redirect()->back();
                }
            }
            // For "All" room types - handle based on what date fields are provided
            elseif ($selectedRoomTypeName == 'All') {
                // If date range is provided, use date range logic
                if ($start_date && $end_date) {
                    $conflictWithUnavailable = DB::table('schedule_booking')
                        ->where('roomid', $roomId)
                        ->whereBetween('invalid_date', [$start_date, $end_date])
                        ->where(function ($q) use ($start_time, $end_time) {
                            $q->where('invalid_time_start', '<', $end_time)
                              ->where('invalid_time_end', '>', $start_time);
                        })
                        ->exists();

                    $conflictWithBooked = DB::table('bookings')
                        ->where('no_room', $roomId)
                        ->whereBetween('booking_date', [$start_date, $end_date])
                        ->where(function ($q) use ($start_time, $end_time) {
                            $q->where('booking_time_start', '<', $end_time)
                              ->where('booking_time_end', '>', $start_time);
                        })
                        ->exists();

                    $conflictWithReserved = DB::table('facility_reservations')
                        ->where('room_id', $roomId)
                        ->where(function ($q) use ($start_date, $end_date) {
                            $q->where(function ($subQ) use ($start_date, $end_date) {
                                $subQ->where('start_date', '<=', $end_date)
                                     ->where('end_date', '>=', $start_date);
                            });
                        })
                        ->where(function ($q) use ($start_time, $end_time) {
                            $q->where('start_time', '<', $end_time)
                              ->where('end_time', '>', $start_time);
                        })
                        ->exists();

                    if ($conflictWithUnavailable || $conflictWithBooked || $conflictWithReserved) {
                        request()->session()->flash('error', "Room $roomId is not available during the selected date range.");
                        return redirect()->back();
                    }
                }
                // If single date is provided, use single date logic
                elseif ($date) {
                    $conflictWithUnavailable = DB::table('schedule_booking')
                        ->where('roomid', $roomId)
                        ->where('invalid_date', $date)
                        ->where(function ($q) use ($start_time, $end_time) {
                            $q->where('invalid_time_start', '<', $end_time)
                              ->where('invalid_time_end', '>', $start_time);
                        })
                        ->exists();

                    $conflictWithBooked = DB::table('bookings')
                        ->where('no_room', $roomId)
                        ->where('booking_date', $date)
                        ->where(function ($q) use ($start_time, $end_time) {
                            $q->where('booking_time_start', '<', $end_time)
                              ->where('booking_time_end', '>', $start_time);
                        })
                        ->exists();

                    if ($conflictWithUnavailable || $conflictWithBooked) {
                        request()->session()->flash('error', "Room $roomId is not available at the selected time.");
                        return redirect()->back();
                    }
                }
            }
        }
    }

    $furnitureCategories = CategoryEquipment::whereHas('furniture')->orderBy('name')->get();
    $electronicCategories = CategoryEquipment::whereHas('electronics')->orderBy('name')->get();

    return view('frontend.index', compact(
        'rooms', 'furnitureCategories', 'electronicCategories',
        'type_rooms', 'type_room', 'date', 'start_date', 'end_date',
        'start_time', 'end_time', 'furniture_category', 'electronic_category',
        'selectedRoomTypeName'
    ));
}


//FrontendController

    public function home()
    {
    
        $rooms = collect(); // Empty collection as a placeholder
        $type_rooms = \App\Models\TypeRooms::orderBy('name')->get(); // Default value for type_room
        $date = null;
        $start_time = null;
        $end_time = null;
        $furniture_category = [];
        $electronic_category = [];
        $furnitureCategories = CategoryEquipment::whereHas('furniture')->orderBy('name')->get();
        $electronicCategories = CategoryEquipment::whereHas('electronics')->orderBy('name')->get();
        return view('frontend.index', compact('rooms', 'type_rooms',
        'date', 'start_time', 'end_time', 'furniture_category', 'electronic_category',
        'furnitureCategories', 'electronicCategories'));
    }


